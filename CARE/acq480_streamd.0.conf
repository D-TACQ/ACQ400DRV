#!/bin/sh

LOG="logger -t acq400_streamd"

LOGS="$LOG site:$site"

source /etc/sysconfig/acq400.conf

ACQ480CLK_RETRAIN_FRACTION=${ACQ480CLK_RETRAIN_FRACTION:-100}

# first arg must be site!
logs() {
		$LOG site:$*	
}
log_engine() {
	$LOG \
		"data_engine_0 $(get.sys /dev/acq400.0.knobs/data_engine_0)"

}
log_engine

training=0

wait_training_done() {
	site=$1
	stf=/var/run/acq480.$site.train
	
	let pollcat=0	
	while [ ! -e  $stf ]; do
		let pollcat=$pollcat+1
		let mod=$pollcat/10
		let mod="$mod*10"
		[ $mod -eq $pollcat ] || $LOG polling:$site
		if [ $pollcat -gt 200 ]; then
			logs $site timeout
			exit 1
		fi
		usleep 100000
	done
	source $stf
	while [ "x$A480_STATUS" = "xTRAINING_STARTED" ]; do
		usleep 100000
		source $stf		
	done

	if [ "x$A480_STATUS" != "xOK" ]; then
		logs $site ERROR training fail
		exit 1
	fi
	logs $site wait_training_done OK
}

# fclk : input clock to the ADC
read_fclk() {
	echo $(get.site 0 SIG:CLK_MB:FREQ) | awk '{ print $2 }'
}

# fs sample rate OUT of the ADC (after decimation)
read_fs() {
	echo $(get.site 0 SIG:CLK_MB:FREQ; get.site $1 ACQ480:FIR:DECIM ) |
		awk '{ print $4!= 0? $2/$4: $2 }'
}
ok_clk() {
	# 10M minimum. except the count tends to round down, so make it 9..
	echo $1 | awk '{ printf "%d\n", $1/9000000 }'
}

clk_MHz() {
	echo $1 | awk '{print $1/1000000}'
}

FCLK=$(read_fclk)

check_site_training() {
	site=$1
	force=${2:-0}
	$LOG check_site_training:$site $force
	
	retry=0
	while [ 1 ]; do		
		FS=$(read_fs $site)
		OKCLK=$(ok_clk $FS)
		[ $OKCLK -ne 0 ] && break

		$LOG "$retry: WARNING CLK $FS TOO SLOW"
		if [ $retry -gt 5 ]; then
			  	$LOG "$retry: ERROR CLK $FS TOO SLOW"
			  	exit 1
		fi
		let retry=$retry+1
	done

	if [ $force -ne 0 ]; then
		logs $site FORCE training
	elif [ $(get.site $site acq480_loti) -ne 0 ];then
		logs $site LOTI detected start training
	elif [ ! -e /var/run/acq480.$site.train ]; then
		logs $site FIRST time training
	else
		source /var/run/acq480.$site.train
		if [ "$A480_STATUS" != "OK" ] || [ "z$A480_CLK" = "z" ] ; then
			logs $site previous TRAIN BAD
		else	
			df=$(echo $FS $A480_FREQ $ACQ480CLK_RETRAIN_FRACTION | awk \
				'{ df=$2-$1; printf "%d\n", $3*sqrt(df*df)/$1 }')
			if [ $df -gt 1 ]; then			
				logs $site CLK change $FS $A480_FREQ $df detected
			else	
				file=/dev/shm/acq480.$site.retrain_requested
				if [ -e $file ]; then
					$LOG retrain_requested:$site
					rm $file
				else
					# all good no training required..
					return
				fi
			fi
		fi
	fi	
	rm -f /var/run/acq480.$site.train
	let training=$training+1

	SITE=$site acq480_train | $LOG & 
	wait_training_done $site	
}

FTF=/dev/shm/acq480_force_training

if [ -e $FTF ]; then
	force=$(cat $FTF)
else
	force=$(get.site 0 acq480_force_training)	
fi

eval $(get.site 0 aggregator)

sitesp="$(echo $sites | tr , \  )"

if [ "x$sitesp" = "x" ]; then
	$LOG ERROR NO SITES
	exit 1
fi

for site in $sitesp; do
	if [ -e /dev/acq480/$site/JC ] && [ "$(get.site $site JC_LOL)" != "0" ]; then
		logs $site acq480_jc_setfreq $(clk_MHz $FCLK)
		SITE=$site acq480_jc_setfreq $(clk_MHz $FCLK) | $LOG		
		let pollcat=1
		while [ "$(get.site $site JC_LOL)" != "0" ]; do
			$LOG "Waiting for JC_LOL"
			usleep 100000			
		done
		logs $site acq480_jc_setfreq done	
	fi		
done

for site in $sitesp; do
	set.site $site dclock_reset 1
	break
done


for site in $sitesp; do
	(set.site $site SIG:CLK:TRAIN_BSY 1
	check_site_training $site $force
	set.site $site SIG:CLK:TRAIN_BSY 0) &
done

for site in $sitesp; do
	wait
done

[ $force -ne 0 ] && set.site 0 acq480_force_training 0

$LOG kickoff training count:$training
# export soft_trigger IF soft_trigger is selected
# maybe special routing eg ACQ1014 where there's a race and should NOT be auto
TRG=$(get.site 1 trg | awk '{ print $1 }')
[ "$TRG" = "trg=1,1,1" ] && export ACQ400D_TRIG="soft_trigger"
